开发心得
    PET1.0 中的扩展（Expansion）被定义为一种由存储压力触发、通过前缀嵌入精度提升来实现的结构性生长过程。
    当树结构检测到叶节点对应的存储块达到容量阈值时，PET 不直接扩展存储块本身，而是通过生成新的子节点、细化前缀嵌入路径，从而增加索引区分能力，并在有限内存条件下提升整体存储效率与可扩展性。
    为保证结构一致性与查询语义的正确性，PET1.0 将扩展过程视为一个独占的阶段性状态。在进入扩展状态后，系统将暂时阻止所有插入与查询操作，直至扩展完成并恢复到稳定状态。为避免数据丢失，工程实现中允许引入临时缓冲机制，用于暂存扩展期间到达的数据流，但该缓冲区不参与在线查询与索引决策。
    PET1.0 采用全局扩展策略。当扩展被触发时，系统将统一增加前缀嵌入深度，即在现有树结构之上整体引入新的一层。该策略保证了所有键值在任意时刻均使用一致的嵌入规则，从而简化查询路径与复杂度分析。尽管该方式可能引发瞬时内存抖动，但该问题被视为后续版本中通过主副树等机制加以优化的工程问题。
    在 PET1.0 中，树结构中的每一个叶节点严格绑定一个存储块。所有映射至该节点前缀区间内的数据摘要均存储于对应的唯一存储块中，节点与存储块之间不存在一对多或多对一关系。
    StorageBlock 是一个与前缀嵌入无关的摘要存储单元，其内部仅基于指纹空间维护统计信息。前缀判定、路由与层级划分均由 PET 结构负责，StorageBlock 不感知自身所对应的前缀区间。在 PET1.0 中，StorageBlock 的内部实现采用固定结构的压缩矩阵形式，用于支持边存在性、权重估计与节点度统计等查询。
    在 PET1.0 中，系统采用 edge-level fingerprint 作为基本摘要粒度。每条边 ⟨u, v⟩ 被整体映射为一个指纹值，并存储于对应叶节点的存储块中。该设计保证了每次扩展仅引入单一前缀位，从而维持二叉树结构的可控性。StorageBlock 内部采用基于哈希的摘要结构以支持高效的边存在性与权重估计查询。节点级查询能力（如精确度统计）被视为更高版本 PET 的扩展目标。
    在 PET1.0 中，每个叶节点绑定一个 StorageBlock，其内部采用基于哈希的摘要结构，并设定固定的容量上限。StorageBlock 的满载状态由其当前存储的不同 edge fingerprint 数量判定。当某一 StorageBlock 的键数量达到预设上限时，系统触发一次全局扩展操作。